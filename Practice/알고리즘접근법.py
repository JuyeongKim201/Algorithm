'''
[트리 순회]
    - 전위 중위 후위:
        왼쪽 subtree -> 오른쪽 subtree는 동일
        가운데 (해당)노드를 무슨 순서로 탐색하냐에 따라 결정
    - 매우 간단한 dfs의 일종임
        현재 노드가 빈 노드('.')가 아니라면: 
        left_node, right_node 설정해주고
        재귀적으로 탐색

2차원 배열 -> 순회를 거치며 1차원 결과값으로 나옴
    - 결과값 구조는 다음과 같음
    - 전위 순회
        [[root],[왼쪽 subtree],[오른쪽 subtree]]
    - 중위 순회
        [[왼쪽 subtree],[root],[오른쪽 subtree]]
    - 후위 순회
        [[왼쪽 subtree],[오른쪽 subtree],[root]]
------------------------------------
[최소 신장 트리] (Kruskal's)
MST: 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리
    - 간선 정보 담을 edges 배열
    - union-find 활용
        1) make-set: 대부분 바로 세팅하면 됨
            - 부모 정보 담을 parent 배열
            - 랭크 정보 담을 rank 배열
        2) find(x): 
            - 루트노드가 아니라면 (parent[x] != x)
            - 재귀적으로 탐색 + 경로 압축 (parent[x] = find(parent[x]))
        3) union(x, y):
            - x, y의 루트 찾고
            - 랭크 비교 후
            - 낮은 랭크의 루트노드의 부모노드 -> 높은 랭크의 루트노드로 설정
    - edges의 모든 edge들에 대해서
        - node1과 node2에 대해 find 수행
            - 같은 루트를 지니지 않는다면 (사이클 형성X)
            - union!



------------------------------------
[위상 정렬]
    - DAG (사이클이 없는 방향 그래프에서 가능)
    - indegree 만들기 (visited는 필요X)
    - 그래프 만들기. 이때 indegree도 함께 채워줌
    - 큐 활용 (bfs와 원리 비슷함)
    - 시작 (while문 전에) 
        indegree 0인 애들 모두 담기
    - while 문 안
        큐에서 꺼내서 방문
        인접노드 indegree -1
        새롭게 indegree 0된 애들 큐에 담기
    
------------------------------------
------------------------------------
# 2주차 알고리즘 구현시 핵심 키워드

1. DFS (Depth-First Search):
    - 재귀 또는 스택: DFS는 재귀 호출을 사용하거나 스택을 사용하여 구현할 수 있다.
    - 방문 처리: 이미 방문한 노드를 다시 방문하지 않도록 처리해야 한다.

2. BFS (Breadth-First Search):
    - 큐: BFS는 큐(Queue)를 사용하여 구현하며, 노드를 방문할 때마다 큐에 인접 노드를 추가한다.
    - 방문 처리: 이미 방문한 노드를 다시 방문하지 않도록 처리해야 한다.

3. Kruskal's Algorithm:
    - 유니온 파인드(Union-Find): 사이클이 생성되지 않도록 확인하는데 유니온 파인드 알고리즘을 사용한다.
    - 간선 정렬: Kruskal 알고리즘은 간선의 가중치를 기준으로 오름차순 정렬해야 한다.

4. Prim's Algorithm:
    - 우선순위 큐: 가중치가 낮은 간선부터 선택하기 위해 우선순위 큐를 사용한다.
    - 방문 처리: 이미 방문한 노드를 다시 방문하지 않도록 처리해야 한다.

5. Kahn's Algorithm (위상 정렬):
    - 진입 차수: 각 노드의 진입 차수를 계산하고, 진입 차수가 0인 노드를 큐에 추가한다.
    - 큐: 큐를 사용하여 진입 차수가 0인 노드를 처리하고 인접 노드의 진입 차수를 감소시킨다.

6. Dijkstra's Algorithm:
    - 우선순위 큐: 가중치가 낮은 간선부터 선택하기 위해 우선순위 큐를 사용한다.
    - 거리 배열: 시작 노드로부터 각 노드까지의 최단 거리를 저장하는 배열을 유지한다.

7. Floyd-Warshall Algorithm:
    - 3중 루프: 모든 노드 쌍에 대해 최단 거리를 계산하기 위해 3중 루프를 사용한다.
    - 거리 행렬: 각 노드 쌍 사이의 최단 거리를 저장하는 2차원 행렬을 사용한다.        

------------------------------------            
------------------------------------
'''

